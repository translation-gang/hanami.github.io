---
title: Guides - Actions Overview
---

# Обзор

Пунктом назначения для HTTP запроса является действие(action), заданное в [маршруте(route)](/guides/routing/overview).
В приложении Hanami **действие является объектом**, а контроллер **модулем Ruby**, который группирует действия.

Такая структура обеспечивает автономность действий жестко разграничивая их контексты. Кроме того, она предотвращает разрастание контроллеров и упрощает тестирование.

## Простое действие

Hanami поставляется с генератором действия. Воспользуемся им:

```shell
hanami generate action web dashboard#index
```

Посмотрим, что получилось:

```ruby
# apps/web/controllers/dashboard/index.rb
module Web::Controllers::Dashboard
  class Index
    include Web::Action

    def call(params)
    end
  end
end
```

### Именование

В начале файла располагается объявление модуля.

Первая его составляющая — это название приложения: `Web`.
Hanami может загружать несколько приложений внутри одного процесса Ruby.
Они расположены в папке `apps/`.
Их имена используются в качестве **модуля высшего уровня, включающего внутренние компоненты**, такие как действия и представления, что позволяет избежать **коллизий имен**.
Если у нас есть еще одно действие `Home::Index` в приложении `Admin`, то они смогут спокойно сосуществовать.

Вторая составляющая — имя определенное соглашением: `Controllers`.
**Все контроллеры содержатся внутри этого модуля.**

<p class="convention">
  Для приложения с именем <code>Web</code> контроллеры будут доступны в модуле <code>Web::Controllers</code>.
</p>

Последняя часть — это имя контроллера, `Dashboard`.

Таким образом, полное имя действия `Web::Controllers::Dashboard::Index`.

<p class="warning">
  Следует избегать совпадения имени действия и приложения, то же самое верно и в отношении контроллера. Например, контроллера <code>Web</code> для приложения <code>Web</code>. Если будет создан контроллер с именем <code>Web::Controllers::Web</code>, то выполнение программы может аварийно завершиться, ссылаясь на невозможность найти некоторые константы, например, в представлениях <code>include Web::Layout</code>. Это обусловлено тем, что интерпретатор начинает поиск констант с текущего модуля, поэтому константа вида <code>Web::Layout</code>, на которую ссылается код внутри <code>Web::Controllers::Web</code> или <code>Web::Controllers::Web::MyAction</code> будет интерпретирована как <code>Web::Controllers::Web::Layout</code>, которую будет невозможно найти, что и приведет к ошибке.
</p>
<p class="warning">
  Если вы считаете абсолютно необходимым назвать контроллер так же, как и приложение, то вам необходимо явно указать пространство имен в тех местах, которые подключаются непосредственно приложением, а не контроллером. Для этого достаточно добавить к ним префикс <code>::</code>. Так в коде представлений придется заменить <code>include Web::Layout</code> на <code>include ::Web::Layout</code>, а в контроллере <code>include Web::Action</code> на <code>include ::Web::Action</code>.
</p>

### Модули действий

Hanami придает особое значение принципу _композиции над наследованием(composition over inheritance)_ и избегает  [антипаттерна суперклассов фреймворка(framework superclass antipattern)](http://michaelfeathers.typepad.com/michael_feathers_blog/2013/01/the-framework-superclass-anti-pattern.html).

Поэтому все компоненты представлены в виде **модулей**, а не основаны на классах.

Как уже было сказано, Hanami позволяет запустить несколько приложений внутри одного Ruby процесса.
Каждое из них имеет собственную конфигурацию.
Чтобы не нарушить разделения действия  из приложений `Web` и `Admin`, мы создали для них `Web::Action` и `Admin::Action` соответственно.

В нашем примере была следующая строка кода: `include Web::Action`.
Это означает, что действие будет выполняться так, как предписано конфигурацией приложения `Web`.

<p class="convention">
  Для приложения <code>Web</code>, действия должно включать примесь(mixin) <code>Web::Action</code>.
</p>

### Интерфейс

Включая модуль `Web::Action` мы делаем наши объекты совместимыми с действиями из  [Hanami::Controller](https://github.com/hanami/controller).
Главное, реализовать метод `#call`, который принимает только один аргумент: `params`.
Это объект, который осуществляет обработку HTTP запроса поступившего от [маршрутизатора](/guides/routing/basic-usage).

Интерфейс напоминает Rack.
И на самом деле, наши действия полностью совместимы с протоколом Rack.

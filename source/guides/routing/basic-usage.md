---
title: Руководство - Использование маршрутов
---

# Использование

## Определение пути

В [нашем стартовом примере](/guides/routing/overview) был использован простой относительный URI: `/hello`.
Такие маршруты мы называем _статическими_.
Это означает, что к ним приводит запрос только по одному **неизменному пути**.
Запрос к `/hello` приведет к ответу, а запрос к `/foo` вернет ошибку `404` (Ресурс не найден).

### Статические пути

```ruby
# apps/web/config/routes.rb
get '/dashboard', to: "dashboard#index"
```

### Динамические пути

Иногда необходимо организовать доступ к динамическим ресурсам. Тогда от URI ждут соответствущей гибкости.
Она достигается посредством переменных пути.
Их объявление состоит из двоеточия, за которым следует имя. Например: `:id`.

Когда запрос получен и направлен в пункт назначения, мы можем получить доступ к соответствующей переменной через `params[:id]`.

```ruby
get '/books/:id', to: 'books#show'
```

В одном пути может быть несколько переменных.

```ruby
get '/books/:book_id/reviews/:id', to: 'reviews#show'
```

### Ограничения переменных

Для каждой переменной можно задать ограничения.
Они должны быть записаны в виде регулярных выражений.
Если при запросе все ограничения удовлетворены, то продолжится его обработка, а иначе будет возвращена ошибка `404`.

```ruby
get '/authors/:id', id: /\d+/, to: 'authors#show'
```

### Необязательные переменные

Бывает полезно определить необязательные части URI.
Они должны быть определены внутри круглых скобок.
Если они обнаружены, то станут доступны как один из параметров переменной Rack env. Иначе параметры будут пусты, но пункт назначения все еще будет достигнут.

```ruby
get '/books(.:format)', to: 'books#show'
```

### Свободные составляющие

Представим, что мы хотим обеспечить доступ к статическим файлам из пользовательского хранилища.
Заранее невозможно узнать, какие файлы будут храниться там, а значит нельзя и задать их маршруты.

Для решения этой проблемы Hanami использует _свободные составляющие_.

```ruby
get '/files/*', to: 'files#show'
```

## Именованные маршруты

Мы можем определить уникальные имена для каждого маршрута, чтобы затем использовать их в других частях приложения.

```ruby
root              to  'home#index'
get '/hello',     to: 'greet#index', as: :greeting
get '/books/:id', to: 'books#show',  as: :book
```

Когда приложение Hanami запускается оно генерирует специальный модуль Ruby в своем пространстве имен. Для приложения `Web` он будет доступен как `Web.routes` и будет использован для получения маршрута по относительному или абсолютному пути во время работы приложения.

```ruby
Web.routes.path(:root)     # => "/"
Web.routes.url(:root)      # => "http://localhost:2300/"

Web.routes.path(:greeting) # => "/hello"
Web.routes.url(:greeting)  # => "http://localhost:2300/hello"
```
Когда такие переменные есть или их несколько, они могут быть определены как хэш.

```ruby
Web.routes.path(:book, id: 1) # => "/books/1"
Web.routes.url(:book, id: 1)  # => "http://localhost:2300/books/1"
```
Абсолютный URL генерируется исходя из настроек `scheme`, `host` и `port` в файле `apps/web/application.rb`.

### Хэлперы маршрутизатора

Полученные при помощи `Web.routes` маршруты полезны благодаря своей доступности из любой части приложения.
Тем не менее, такой синтаксис не совсем удобен.

Hanami позволяет использовать _хэлперы маршрутизатора_, доступные из `routes` в: **экшенах(actions)**, **представлениях(views)** и **шаблонах(templates)**.

```ruby
<%= routes.path(:greeting) %>
<%= routes.url(:greeting) %>
```

Или

```ruby
<%= routes.greeting_path %>
<%= routes.greeting_url %>
```

## Пространства имен

Если мы хотим сгруппировать набор ресурсов под одним префиксом, то можем использовать `пространства имен(namespace)`.

```ruby
namespace 'docs' do
  get '/installation', to: 'docs#installation'
  get '/usage',        to: 'docs#usage'
end

# Будет сгенерировано:
#
#   /docs/installation
#   /docs/usage
```

## Переадресация

В случае когда обстоятельства не позволяют переопределить маршрут мы можем настроить HTTP переадресацию на уровне маршрутизатора.

```ruby
redirect '/old', to: '/new'
```
